<?php namespace Manevia;

    /********************************************************************************
    * JSON Web Token Handler | PHP 5.6+
    *
    * A simple class for both signing and verifying JSON WEb Tokens.  Additionally,
    * a method is provided for generating secrets.  It currently supports HS256,
    * HS384, and HS512, but eventually support for the corresponding RS and ES
    * algorithms will be added!
    *
    * @author Jabari J. Hunt <jabari@jabari.net>
    * @todo Add support for RS and ES algorithms
    ********************************************************************************/

	class JWT
	{
        /********************************************************************************
         * CLASS VARIABLES
         * @var array ALGORITHM_TYPE_HS256
         * @var array ALGORITHM_TYPE_HS384
         * @var array ALGORITHM_TYPE_HS512
         * @var array ALGORITHM_TYPE_NONE
         * @var array ALGORITHM_TYPES
         * @var array $algorithm;
         ********************************************************************************/

            const ALGORITHM_TYPE_HS256 = ['name' => 'HS256', 'sha' => 'sha256', 'length' => '32'];
            const ALGORITHM_TYPE_HS384 = ['name' => 'HS384', 'sha' => 'sha384', 'length' => '48'];
            const ALGORITHM_TYPE_HS512 = ['name' => 'HS512', 'sha' => 'sha512', 'length' => '64'];
            const ALGORITHM_TYPE_NONE  = ['name' => 'none', 'sha' => NULL, 'length' => NULL];

            const ALGORITHM_TYPES =
            [
                'HS256' => self::ALGORITHM_TYPE_HS256,
                'HS384' => self::ALGORITHM_TYPE_HS384,
                'HS512' => self::ALGORITHM_TYPE_HS512,
                'none'  => self::ALGORITHM_TYPE_NONE
            ];

            private $algorithm;

        /********************************************************************************
         * CONSTRUCT METHOD
         * @param array $algorithm
         ********************************************************************************/

            public function __construct(Array $algorithm = self::ALGORITHM_TYPE_HS256)
            {
                // SET CLASS ALGORITHM VARIABLE

                    if (in_array($algorithm, self::ALGORITHM_TYPES)) {$this->algorithm = $algorithm;}
            }

        //////////////////////////////////////////////
        // PUBLIC METHODS
        //////////////////////////////////////////////

            /********************************************************************************
             * SIGN METHOD
             * @param array $payload
             * @param string $secretOrPrivateKey
             * @return string
             ********************************************************************************/

                final public function sign(Array $payload, $secretOrPrivateKey)
                {
                    // BUILD TOKEN HEADER AND PAYLOAD

                        $token  = self::encodePart(['alg' => $this->algorithm['name'], 'type' => 'JWT']);
                        $token .= '.' . self::encodePart($payload);

                    // SIGN THE TOKEN

                        if
                        (
                            $this->algorithm === self::ALGORITHM_TYPE_HS256 ||
                            $this->algorithm === self::ALGORITHM_TYPE_HS384 ||
                            $this->algorithm === self::ALGORITHM_TYPE_HS512
                        )
                        {$token .= '.' . self::encodePart(hash_hmac($this->algorithm['sha'], $token, $secretOrPrivateKey), FALSE);}
                        else {$token .= '.';}

                    // RETURN THE TOKEN

                        return $token;
                }

            /********************************************************************************
             * VERIFY METHOD
             * @param string $token
             * @param string $secretOrPublicKey
             * @return array
             ********************************************************************************/

                final public function verify($token, $secretOrPublicKey)
                {
                    // SET INITIAL VARIABLES | MAKE SURE REQUIRED PARTS EXIST

                        $data['isVerified'] = FALSE;
                        list($header, $payload, $signature) = explode('.', $token);

                        if (!empty($header) && !empty($payload))
                        {
                            // EXTRACT HEADER AND PAYLOAD

                                $data['header']    = self::decodePart($header);
                                $data['payload']   = self::decodePart($payload);
                                $data['signature'] = self::decodePart($signature, FALSE);

                            // VALIDATE SIGNATURE

                                if (!empty($data['header']->alg) && $data['header']->alg !== 'none')
                                {
                                    // HS256, HS384, HS512

                                        if
                                        (
                                            $this->algorithm === self::ALGORITHM_TYPE_HS256 ||
                                            $this->algorithm === self::ALGORITHM_TYPE_HS384 ||
                                            $this->algorithm === self::ALGORITHM_TYPE_HS512
                                        )
                                        {
                                            $sha = self::ALGORITHM_TYPES[$data['header']->alg]['sha'];

                                            if
                                            (
                                                !empty($sha) &&
                                                $signature === self::encodePart(hash_hmac($sha, "{$header}.{$payload}", $secretOrPublicKey), FALSE)
                                            )
                                            {$data['isVerified'] = TRUE;}
                                        }
                                }

                        }

                    // RETURN DATA

                        return $data;
                }

            /********************************************************************************
             * GENERATE SECRET METHOD
             * @param array $algorithm
             * @return string
             ********************************************************************************/

                final public static function generateSecret($algorithm = self::ALGORITHM_TYPE_HS256)
                {
                    return in_array($algorithm, self::ALGORITHM_TYPES) ? self::encodePart(openssl_random_pseudo_bytes($algorithm['length']), FALSE) : NULL;
                }

        //////////////////////////////////////////////
        // PRIVATE METHODS
        //////////////////////////////////////////////

            /********************************************************************************
             * ENCODE PART METHOD
             * @param mixed $data
             * @param boolean $encodeJSON
             * @return string
             ********************************************************************************/

                private static function encodePart($data, $encodeJSON = TRUE)
                {
                    if ($encodeJSON) {$data = json_encode($data);}
                    return base64_encode($data);
                }

            /********************************************************************************
             * DECODE PART METHOD
             * @param string $data
             * @param boolean $decodeJSON
             * @return array
             ********************************************************************************/

                private static function decodePart($data, $decodeJSON = TRUE)
                {
                    $data = base64_decode($data);
                    return $decodeJSON ? json_decode($data) : $data;
                }
	}

?>