<?php namespace Manevia;

    /**
	*	JSON Web Token Handler
	*	AUTHOR: Jabari J. Hunt
	*	E-MAIL: jabari@jabari.net
	*	   PHP: 5.6+
	**/

	final class JWT
	{
        //////////////////////////////////////////////
        // CLASS VARIABLES
        //////////////////////////////////////////////

            const ALGORITHM_TYPE_HS256 = ['name' => 'HS256', 'sha' => 'sha256', 'length' => '32'];
            const ALGORITHM_TYPE_HS384 = ['name' => 'HS384', 'sha' => 'sha384', 'length' => '48'];
            const ALGORITHM_TYPE_HS512 = ['name' => 'HS512', 'sha' => 'sha512', 'length' => '64'];
            const ALGORITHM_TYPE_NONE  = ['name' => 'none', 'sha' => NULL, 'length' => NULL];

            const ALGORITHM_TYPES =
            [
                'HS256' => self::ALGORITHM_TYPE_HS256,
                'HS384' => self::ALGORITHM_TYPE_HS384,
                'HS512' => self::ALGORITHM_TYPE_HS512,
                'none'  => self::ALGORITHM_TYPE_NONE
            ];

            private $algorithm;

        //////////////////////////////////////////////
        // CONSTRUCT METHOD
        //////////////////////////////////////////////

            public function __construct(Array $algorithm = self::ALGORITHM_TYPE_HS256)
            {
                // SET CLASS ALGORITHM VARIABLE

                    if (in_array($algorithm, self::ALGORITHM_TYPES)) {$this->algorithm = $algorithm;}
            }

        //////////////////////////////////////////////
        // PUBLIC METHODS
        //////////////////////////////////////////////

            public function sign(Array $payload, $secretOrPrivateKey)
            {
                // BUILD TOKEN HEADER AND PAYLOAD

                    $token  = $this->encodePart(['alg' => $this->algorithm['name'], 'type' => 'JWT']);
                    $token .= '.' . $this->encodePart($payload);

                // SIGN THE TOKEN

                    if
                    (
                        $this->algorithm === self::ALGORITHM_TYPE_HS256 ||
                        $this->algorithm === self::ALGORITHM_TYPE_HS384 ||
                        $this->algorithm === self::ALGORITHM_TYPE_HS512
                    )
                    {$token .= '.' . base64_encode(hash_hmac($this->algorithm['sha'], $token, $secretOrPrivateKey));}
                    else {$token .= '.';}

                // RETURN THE TOKEN

                    return $token;
            }

            public function verify($token, $secretOrPublicKey)
            {
                // SET INITIAL VARIABLES | MAKE SURE REQUIRED PARTS EXIST

                    $data['isVerified'] = FALSE;
                    list($header, $payload, $signature) = explode('.', $token);

                    if
                    (
                        !empty($header) &&
                        !empty($payload)
                    )
                    {
                        // EXTRACT HEADER AND PAYLOAD

                            $data['header']    = self::decodePart($header);
                            $data['payload']   = self::decodePart($payload);
                            $data['signature'] = $signature;
                            $data['token']     = $token;

                        // VALIDATE SIGNATURE

                            if (!empty($data['header']->alg) && $data['header']->alg !== 'none')
                            {
                                // HS256, HS384, HS512

                                    if
                                    (
                                        $this->algorithm === self::ALGORITHM_TYPE_HS256 ||
                                        $this->algorithm === self::ALGORITHM_TYPE_HS384 ||
                                        $this->algorithm === self::ALGORITHM_TYPE_HS512
                                    )
                                    {
                                        $sha = self::ALGORITHM_TYPES[$data['header']->alg]['sha'];

                                        if
                                        (
                                            !empty($sha) &&
                                            $signature === base64_encode(hash_hmac($sha, "{$header}.{$payload}", $secretOrPublicKey))
                                        )
                                        {$data['isVerified'] = TRUE;}
                                    }
                            }

                    }

                // RETURN DATA

                    return $data;
            }

            public static function generateSecret($algorithm = self::ALGORITHM_TYPE_HS256)
            {
                return in_array($algorithm, self::ALGORITHM_TYPES) ? base64_encode(openssl_random_pseudo_bytes($algorithm['length'])) : NULL;
            }

        //////////////////////////////////////////////
        // PRIVATE METHODS
        //////////////////////////////////////////////

            private static function encodePart(Array $data) {return base64_encode(json_encode($data));}

            private static function decodePart($data) {return json_decode(base64_decode($data));}
	}

?>