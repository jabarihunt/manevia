<?php namespace Manevia;

    /********************************************************************************
    * JSON Web Token Handler | PHP 5.6+
    *
    * A simple class for both signing and verifying JSON WEb Tokens.  Additionally,
    * a method is provided for generating secrets.  It currently supports HS256,
    * HS384, and HS512, but eventually support for the corresponding RS and ES
    * algorithms will be added!
    *
    * JWT::generateSecret() generates a secret with twice the recommended key length.
    *
    * @author Jabari J. Hunt <jabari@jabari.net>
    * @todo Add support for RS and ES algorithms
    ********************************************************************************/

	class JWT
	{
        /********************************************************************************
         * CLASS VARIABLES
         * @var array ALGORITHM_TYPE_HS256
         * @var array ALGORITHM_TYPE_HS384
         * @var array ALGORITHM_TYPE_HS512
         * @var array ALGORITHM_TYPE_NONE
         * @var array ALGORITHM_TYPES
         * @var array $algorithm;
         ********************************************************************************/

            const ALGORITHM_TYPE_HS256 = ['name' => 'HS256', 'sha' => 'sha256', 'length' => '64'];
            const ALGORITHM_TYPE_HS384 = ['name' => 'HS384', 'sha' => 'sha384', 'length' => '96'];
            const ALGORITHM_TYPE_HS512 = ['name' => 'HS512', 'sha' => 'sha512', 'length' => '128'];
            const ALGORITHM_TYPE_NONE  = ['name' => 'none', 'sha' => NULL, 'length' => NULL];

            const ALGORITHM_TYPES =
            [
                'HS256' => self::ALGORITHM_TYPE_HS256,
                'HS384' => self::ALGORITHM_TYPE_HS384,
                'HS512' => self::ALGORITHM_TYPE_HS512,
                'none'  => self::ALGORITHM_TYPE_NONE
            ];

        //////////////////////////////////////////////
        // PUBLIC METHODS
        //////////////////////////////////////////////

            /********************************************************************************
             * SIGN METHOD
             * @param array $payload
             * @param string $secretOrPrivateKey
             * @param array $algorithm
             * @throws \Exception Invalid algorithm passed to JWT::sign().
             * @return string
             ********************************************************************************/

                final public static function sign(Array $payload, $secretOrPrivateKey, Array $algorithm = self::ALGORITHM_TYPE_HS256)
                {
                    // MAKE SURE A SUPPORTED ALGORITHM WAS PASSED

                        if (!in_array($algorithm, self::ALGORITHM_TYPES)) {throw new \Exception('Invalid algorithm passed to JWT::sign().');}

                    // BUILD TOKEN HEADER AND PAYLOAD

                        $token  = self::encode(['alg' => $algorithm['name'], 'type' => 'JWT']);
                        $token .= '.' . self::encode($payload);

                    // SIGN THE TOKEN

                        if
                        (
                            $algorithm === self::ALGORITHM_TYPE_HS256 ||
                            $algorithm === self::ALGORITHM_TYPE_HS384 ||
                            $algorithm === self::ALGORITHM_TYPE_HS512
                        )
                        {$token .= '.' . self::encode(hash_hmac($algorithm['sha'], $token, $secretOrPrivateKey), FALSE);}
                        else if ($algorithm === self::ALGORITHM_TYPE_NONE) {$token .= '.';}

                    // RETURN THE TOKEN

                        return $token;
                }

            /********************************************************************************
             * VERIFY METHOD
             * @param string $token
             * @param string $secretOrPublicKey
             * @throws \Exception Token signed with unsupported algorithm.
             * @return array
             ********************************************************************************/

                final public static function verify($token, $secretOrPublicKey)
                {
                    // SET INITIAL VARIABLES | MAKE SURE REQUIRED PARTS EXIST

                        $data['isVerified'] = FALSE;
                        list($header, $payload, $signature) = explode('.', $token);

                        if (!empty($header) && !empty($payload))
                        {
                            // EXTRACT HEADER AND PAYLOAD

                                $data['header']    = self::decode($header);
                                $data['payload']   = self::decode($payload);
                                $data['signature'] = $signature;

                            // VALIDATE SIGNATURE

                                if (!empty($data['header']->alg) && $data['header']->alg !== 'none')
                                {
                                    // GET ALGORITHM

                                        if (!empty(self::ALGORITHM_TYPES[$data['header']->alg])) {$algorithm = self::ALGORITHM_TYPES[$data['header']->alg];}
                                        else {throw new \Exception('Token signed with unsupported algorithm.');}

                                    // HS256, HS384, HS512

                                        if
                                        (
                                            $algorithm === self::ALGORITHM_TYPE_HS256 ||
                                            $algorithm === self::ALGORITHM_TYPE_HS384 ||
                                            $algorithm === self::ALGORITHM_TYPE_HS512
                                        )
                                        {
                                            $sha = self::ALGORITHM_TYPES[$data['header']->alg]['sha'];

                                            if
                                            (
                                                !empty($sha) &&
                                                $signature === self::encode(hash_hmac($sha, "{$header}.{$payload}", $secretOrPublicKey), FALSE)
                                            )
                                            {$data['isVerified'] = TRUE;}
                                        }
                                }

                        }

                    // RETURN DATA

                        return $data;
                }

            /********************************************************************************
             * GENERATE SECRET METHOD
             * @param array $algorithm
             * @throws \Exception
             * @return string
             ********************************************************************************/

                final public static function generateSecret($algorithm = self::ALGORITHM_TYPE_HS256)
                {
                    if (!in_array($algorithm, self::ALGORITHM_TYPES)) {throw new \Exception('Invalid algorithm passed to JWT::generateSecret().');}
                    return in_array($algorithm, self::ALGORITHM_TYPES) ? base64_encode(random_bytes($algorithm['length'])) : NULL;
                }

        //////////////////////////////////////////////
        // PRIVATE METHODS
        //////////////////////////////////////////////

            /********************************************************************************
             * ENCODE METHOD
             * @param mixed $data
             * @param boolean $encodeJSON
             * @return string
             ********************************************************************************/

                private static function encode($data, $encodeJSON = TRUE)
                {
                    if ($encodeJSON) {$data = json_encode($data);}
                    return rtrim(strtr(base64_encode($data), '+/', '-_'), '=');
                }

            /********************************************************************************
             * DECODE METHOD
             * @param string $data
             * @param boolean $decodeJSON
             * @return array
             ********************************************************************************/

                private static function decode($data, $decodeJSON = TRUE)
                {
                    $data = base64_decode(str_pad(strtr($data, '-_', '+/'), strlen($data) % 4, '=', STR_PAD_RIGHT));
                    return $decodeJSON ? json_decode($data) : $data;
                }
	}

?>